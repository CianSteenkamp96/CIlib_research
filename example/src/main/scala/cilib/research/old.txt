

  def createCollection2(envX: EnvironmentX): RVar[NonEmptyList[MGParticle]] = {
    var count = 0
    val ids =
      envX.cp.swarmSizes.toList.zipWithIndex.flatMap(x =>
        if (x._1 >= 1) (1 to x._1).toList.map(_ => x._2) else List())
    ids.toNel.get.traverse(
      id =>
        PositionX
          .createPositionX(envX)
          .map(p => {
            count = count + 1
            val particle = MGParticle(count, p, p, p.zeroed, id, Lambda.Rij_LI(count, envX))
//            println(particle.id)
            particle
          })
    )
  }

  def Rij_LI(particleID: Int, envX: EnvironmentX): Lambda =
    if (particleID % 2 == 0) {
      println("I chose this one")
      new Lambda(Dist.stdUniform.replicateM(envX.bounds.size).map(_.toNel.get),
                 _ => Dist.stdUniform.replicateM(envX.bounds.size).map(_.toNel.get))
                 }
    else {

      println("I chose this one other one")
      new Lambda(RVar.pure(List.fill(envX.bounds.size)(1.0).toNel.get),
                 rl => rl.map(_.map(x => x - 0.0005)))
                 }


  var state = 1.0
  var count = 0

  def updateState =
    if (count == 49) {
      count = 0
      state = state - 0.0005
      if (state < 0.0000)
        state =  1.0
    } else {
      count = count + 1
    }

  def R_RIJLI(ug: Double , envX: EnvironmentX): Lambda =
    new Lambda(
      Dist.stdUniform.flatMap(chance => {
        if (chance > 0.50)
          Dist.stdUniform.replicateM(envX.bounds.size).map(_.toNel.get)
        else
          RVar.pure(List.fill(envX.bounds.size)(1.0).toNel.get)
      }),
      rl =>
        rl.flatMap(list => {
          Dist.stdUniform.flatMap(chance => {
            updateState
            if (chance > 0.50)
              Dist.stdUniform
                .replicateM(envX.bounds.size)
                .map(_.toNel.get.append(NonEmptyList(state)))
            else
              RVar.pure(List.fill(envX.bounds.size)(state).toNel.get)
          })
        })
    )
